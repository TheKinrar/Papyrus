From 95186e5d755e7baabe30367878fb7829e5b9e7cc Mon Sep 17 00:00:00 2001
From: Indhi Rousseau <contact@thekinrar.fr>
Date: Wed, 9 Oct 2019 19:50:39 +0100
Subject: [PATCH] Material Class/Enum Plugin Compatibility


diff --git a/pom.xml b/pom.xml
index d83f303c25..c01bbda620 100644
--- a/pom.xml
+++ b/pom.xml
@@ -140,6 +140,13 @@
             <version>4.8.47</version>
             <scope>test</scope>
         </dependency>
+        <!-- Papyrus - Compatibility -->
+        <dependency>
+            <groupId>org.javassist</groupId>
+            <artifactId>javassist</artifactId>
+            <version>3.25.0-GA</version>
+            <scope>compile</scope>
+        </dependency>
     </dependencies>
 
     <repositories>
@@ -296,6 +303,7 @@
                                     <shadedPattern>org.bukkit.craftbukkit.v${minecraft_version}</shadedPattern>
                                     <excludes>
                                         <exclude>org.bukkit.craftbukkit.Main*</exclude>
+                                        <exclude>fr.thekinrar.papyrus.compat.*</exclude>
                                     </excludes>
                                 </relocation>
                                 <relocation>
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatClass.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatClass.java
new file mode 100644
index 0000000000..812175524b
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatClass.java
@@ -0,0 +1,24 @@
+package fr.thekinrar.papyrus.compat;
+
+import org.bukkit.Material;
+
+public class CompatClass {
+
+    private static final Class<Material> handle = Material.class;
+
+    @Compatibility
+    public static boolean isEnum(Class clazz) {
+        if(clazz.equals(handle))
+            return true;
+
+        return clazz.isEnum();
+    }
+
+    @Compatibility
+    public static Object[] getEnumConstants(Class clazz) {
+        if(clazz.equals(handle))
+            return Material.values();
+
+        return clazz.getEnumConstants();
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java
new file mode 100644
index 0000000000..9d46fe510b
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumMap.java
@@ -0,0 +1,144 @@
+package fr.thekinrar.papyrus.compat;
+
+import org.bukkit.Material;
+
+import java.util.AbstractMap;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumMap<K, V> extends AbstractMap<K, V> implements java.io.Serializable, Cloneable {
+
+    private boolean realEnum;
+    private AbstractMap<Object, V> realMap;
+
+    private HashMap<Material, V> materialMap;
+
+    public CompatEnumMap(Class keyType) {
+        if(keyType.isEnum()) {
+            realEnum = true;
+            realMap = new EnumMap(keyType);
+        } else {
+            materialMap = new HashMap<>(Material.values().length);
+        }
+    }
+
+    private AbstractMap<Object, V> cloneRealMap() {
+        try {
+            return (AbstractMap<Object, V>) realMap.getClass().getMethod("clone").invoke(realMap);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public CompatEnumMap(CompatEnumMap<K, ? extends V> m) {
+        realEnum = m.realEnum;
+
+        if(realEnum)
+            realMap = (AbstractMap<Object, V>) m.cloneRealMap();
+        else
+            materialMap = (HashMap<Material, V>) m.materialMap.clone();
+    }
+
+    public CompatEnumMap(Map<K, ? extends V> m) {
+        if (m instanceof CompatEnumMap) {
+            CompatEnumMap<K, ? extends V> em = (CompatEnumMap<K, ? extends V>) m;
+
+            realEnum = em.realEnum;
+
+            if(realEnum)
+                realMap = (AbstractMap<Object, V>) em.cloneRealMap();
+            else
+                materialMap = (HashMap<Material, V>) em.materialMap.clone();
+        } else {
+            if (m.isEmpty())
+                throw new IllegalArgumentException("Specified map is empty");
+
+            Class<K> keyType = (Class<K>) m.keySet().iterator().next().getClass();
+
+            if(m.keySet().iterator().next().getClass().isEnum()) {
+                realEnum = true;
+                realMap = new EnumMap(keyType);
+            } else {
+                materialMap = new HashMap<>(Material.values().length);
+            }
+
+            putAll(m);
+        }
+    }
+
+    public int size() {
+        return realEnum ? realMap.size() : materialMap.size();
+    }
+
+    public boolean containsValue(Object value) {
+        return realEnum ? realMap.containsValue(value) : materialMap.containsValue(value);
+    }
+
+    public boolean containsKey(Object key) {
+        return realEnum ? realMap.containsKey(key) : materialMap.containsKey(key);
+    }
+
+    public V get(Object key) {
+        return realEnum ? realMap.get(key) : materialMap.get(key);
+    }
+
+    public V put(K key, V value) {
+        return realEnum ? realMap.put(key, value) : materialMap.put((Material) key, value);
+    }
+
+    public V put(Material key, V value) {
+        return materialMap.put((Material) key, value);
+    }
+
+    public V remove(Object key) {
+        return realEnum ? realMap.remove(key) : materialMap.remove(key);
+    }
+
+    public void putAll(Map<? extends K, ? extends V> m) {
+        for(Entry<? extends K, ? extends V> entry : m.entrySet()) {
+            put(entry.getKey(), entry.getValue());
+        }
+    }
+
+    public void clear() {
+        if(realEnum)
+            realMap.clear();
+        else
+            materialMap.clear();
+    }
+
+    public Set<K> keySet() {
+        return realEnum ? (Set<K>) realMap.keySet() : (Set<K>) materialMap.keySet();
+    }
+
+    public Collection<V> values() {
+        return realEnum ? realMap.values() : materialMap.values();
+    }
+
+    public Set<Map.Entry<K,V>> entrySet() {
+        Set<Map.Entry<K, V>> set = new HashSet<>(realEnum ? realMap.size() : materialMap.size());
+
+        for(Map.Entry e : realEnum ? realMap.entrySet() : materialMap.entrySet()) {
+            set.add(e);
+        }
+
+        return set;
+    }
+
+    public boolean equals(Object o) {
+        return realEnum ? realMap.equals(o) : materialMap.equals(o);
+    }
+
+    public int hashCode() {
+        return realEnum ? realMap.hashCode() : materialMap.hashCode();
+    }
+
+    public CompatEnumMap<K, V> clone() {
+        return new CompatEnumMap<K, V>(this);
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java
new file mode 100644
index 0000000000..e7ebe8d9f6
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatEnumSet.java
@@ -0,0 +1,250 @@
+package fr.thekinrar.papyrus.compat;
+
+import com.google.common.collect.Iterators;
+import org.bukkit.Material;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.AbstractSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Objects;
+
+@SuppressWarnings("unchecked")
+public class CompatEnumSet<E> extends AbstractSet<E> implements Cloneable, java.io.Serializable {
+
+    private boolean realEnum;
+    private EnumSet realSet;
+    private Enum[] realUniverse;
+
+    private final Class clazz;
+
+    private HashSet<Material> materialSet;
+
+    public CompatEnumSet(Class<Enum> clazz, EnumSet realSet) {
+        this.realSet = realSet;
+        this.realEnum = true;
+        this.realUniverse = clazz.getEnumConstants();
+        this.clazz = clazz;
+    }
+
+    private CompatEnumSet(Class elementType) {
+        if(elementType.isEnum()) {
+            realEnum = true;
+            realSet = EnumSet.noneOf(elementType);
+            try {
+                realUniverse = (Enum[]) elementType.getMethod("values").invoke(null);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            materialSet = new HashSet<>(Material.values().length);
+        }
+
+        this.clazz = elementType;
+    }
+
+    public static <E> CompatEnumSet<E> noneOf(Class elementType) {
+        return new CompatEnumSet(elementType);
+    }
+
+    public static <E> CompatEnumSet<E> allOf(Class<E> elementType) {
+        CompatEnumSet<E> result = noneOf(elementType);
+        result.addAll();
+        return result;
+    }
+
+    void addAll() {
+        if(realEnum) {
+            realSet.addAll(Arrays.asList(realUniverse));
+        } else {
+            materialSet.addAll(Arrays.asList(Material.values()));
+        }
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(CompatEnumSet<E> s) {
+        return s.clone();
+    }
+
+    public static <E> CompatEnumSet<E> copyOf(Collection<E> c) {
+        if (c instanceof CompatEnumSet) {
+            return ((CompatEnumSet<E>)c).clone();
+        } else {
+            if (c.isEmpty())
+                throw new IllegalArgumentException("Collection is empty");
+            Iterator<E> i = c.iterator();
+            E first = i.next();
+            CompatEnumSet<E> result = CompatEnumSet.of(first);
+            while (i.hasNext())
+                result.add(i.next());
+            return result;
+        }
+    }
+
+    public static <E> CompatEnumSet<E> complementOf(CompatEnumSet<E> s) {
+        CompatEnumSet<E> result = copyOf(s);
+        result.complement();
+        return result;
+    }
+
+    private static Class declaringClass(Class clazz) {
+        if(clazz.isEnum())
+            return clazz;
+
+        if(clazz.getSuperclass().isEnum())
+            return clazz.getSuperclass();
+
+        return clazz;
+    }
+
+    public static <E> CompatEnumSet<E> of(Iterable<E> elements) {
+        Iterator<E> it = elements.iterator();
+
+        if(!it.hasNext()) throw new IllegalArgumentException("Can create empty CompatEnumSet");
+
+        CompatEnumSet set = of(it.next());
+        Iterators.addAll(set, it);
+
+        return set;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e.getClass()));
+        result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object e1, Object e2) {
+        if(e2.getClass().isArray())
+            return of(e1, (Object[]) e2);
+
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add((E) e1);
+        result.add((E) e2);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(E e1, E e2, E e3, E e4,
+                                                          E e5) {
+        CompatEnumSet<E> result = noneOf(declaringClass(e1.getClass()));
+        result.add(e1);
+        result.add(e2);
+        result.add(e3);
+        result.add(e4);
+        result.add(e5);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> of(Object first, Object... rest) {
+        Class clazz = declaringClass(first.getClass());
+
+        if(clazz.isEnum()) {
+            return new CompatEnumSet(clazz, EnumSet.of((Enum) first, (Enum[]) rest));
+        }
+
+        CompatEnumSet<E> result = noneOf(declaringClass(first.getClass()));
+        result.add((E) first);
+        for (Object e : rest)
+            result.add((E) e);
+        return result;
+    }
+
+    public static <E> CompatEnumSet<E> range(E _from, E to) {
+        Comparable<E> from = (Comparable) _from;
+
+        if (from.compareTo(to) > 0)
+            throw new IllegalArgumentException(from + " > " + to);
+
+        Class clazz = from.getClass().getDeclaringClass();
+        CompatEnumSet<E> result = noneOf(Objects.isNull(clazz) ? from.getClass() : clazz);
+        result.addRange((E) from, to);
+        return result;
+    }
+
+    void addRange(E from, E to) {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getDeclaredMethod("addRange", Object.class, Object.class);
+                m.setAccessible(true);
+                m.invoke(realSet, from, to);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            int i1 = ((Material) from).ordinal();
+            int i2 = ((Material) to).ordinal();
+
+            for(int i = i1; i <= i2; ++i) {
+                materialSet.add(Material.values()[i]);
+            }
+        }
+    }
+
+    public boolean add(E o) {
+        if(realEnum) {
+            return realSet.add(o);
+        } else {
+            return materialSet.add((Material) o);
+        }
+    }
+
+    public CompatEnumSet<E> clone() {
+        CompatEnumSet copy;
+        if(realEnum) {
+            copy = new CompatEnumSet(clazz, realSet.clone());
+        } else {
+            copy = new CompatEnumSet(Material.class);
+            copy.addAll(this);
+        }
+        return copy;
+    }
+
+    void complement() {
+        if(realEnum) {
+            try {
+                Method m = realSet.getClass().getDeclaredMethod("complement");
+                m.setAccessible(true);
+                m.invoke(realSet);
+            } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
+                throw new RuntimeException(e);
+            }
+        } else {
+            for(Material material : Material.values()) {
+                if(materialSet.contains(material))
+                    materialSet.remove(material);
+                else
+                    materialSet.add(material);
+            }
+        }
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return realEnum ? (Iterator<E>) realSet.iterator() : (Iterator<E>) materialSet.iterator();
+    }
+
+    @Override
+    public int size() {
+        return realEnum ? realSet.size() : materialSet.size();
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/CompatField.java b/src/main/java/fr/thekinrar/papyrus/compat/CompatField.java
new file mode 100644
index 0000000000..39ed4779ad
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/CompatField.java
@@ -0,0 +1,18 @@
+package fr.thekinrar.papyrus.compat;
+
+import org.bukkit.Material;
+
+import java.lang.reflect.Field;
+
+public class CompatField {
+
+    private static final Class<Material> handle = Material.class;
+
+    @Compatibility
+    public static boolean isEnumConstant(Field field) {
+        if(field.getDeclaringClass().equals(handle))
+            return true;
+
+        return field.isEnumConstant();
+    }
+}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/Compatibility.java b/src/main/java/fr/thekinrar/papyrus/compat/Compatibility.java
new file mode 100644
index 0000000000..50c5799cca
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/Compatibility.java
@@ -0,0 +1,13 @@
+package fr.thekinrar.papyrus.compat;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Indicates that a method has a different behaviour than the default Class behaviour for compatibility reasons
+ */
+@Target(ElementType.METHOD)
+@Retention(RetentionPolicy.SOURCE)
+@interface Compatibility {}
diff --git a/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java b/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java
new file mode 100644
index 0000000000..707268ea3d
--- /dev/null
+++ b/src/main/java/fr/thekinrar/papyrus/compat/PapyrusCompat.java
@@ -0,0 +1,117 @@
+package fr.thekinrar.papyrus.compat;
+
+import javassist.CannotCompileException;
+import javassist.ClassPool;
+import javassist.CtClass;
+import javassist.CtField;
+import javassist.NotFoundException;
+import javassist.bytecode.BadBytecode;
+import javassist.bytecode.ConstPool;
+import javassist.expr.Cast;
+import javassist.expr.ExprEditor;
+import javassist.expr.MethodCall;
+import org.bukkit.Material;
+
+import java.io.ByteArrayInputStream;
+import java.util.Arrays;
+
+public class PapyrusCompat {
+
+    private static final CompatExprEditor editor = new CompatExprEditor();
+
+    @Compatibility
+    public static Object cast(Object o) {
+        return o;
+    }
+
+    public static byte[] transform(byte[] classfileBuffer) {
+        try {
+            ClassPool cp = ClassPool.getDefault();
+            CtClass cc = cp.makeClass(new ByteArrayInputStream(classfileBuffer));
+
+            ConstPool pool = cc.getClassFile().getConstPool();
+            pool.renameClass("java/util/EnumMap", "fr/thekinrar/papyrus/compat/CompatEnumMap");
+            pool.renameClass("java/util/EnumSet", "fr/thekinrar/papyrus/compat/CompatEnumSet");
+
+            for(CtField field : cc.getDeclaredFields()) {
+                if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumMap;")) {
+                    field.setType(cp.get("fr.thekinrar.papyrus.compat.CompatEnumMap"));
+                } else if(field.getFieldInfo().getDescriptor().equals("Ljava/util/EnumSet;")) {
+                    field.setType(cp.get("fr.thekinrar.papyrus.compat.CompatEnumSet"));
+                }
+            }
+
+            if(cc.getClassInitializer() != null)
+                cc.getClassInitializer().instrument(editor);
+
+            Arrays.stream(cc.getDeclaredMethods()).forEach(method -> {
+                String descriptor = method.getMethodInfo().getDescriptor();
+
+                if(descriptor.contains("Ljava/util/EnumSet;") || descriptor.contains("Ljava/util/EnumMap;")) {
+                    method.getMethodInfo().setDescriptor(descriptor
+                        .replace("Ljava/util/EnumSet;", "Lfr/thekinrar/papyrus/compat/CompatEnumSet;")
+                        .replace("Ljava/util/EnumMap;", "Lfr/thekinrar/papyrus/compat/CompatEnumMap;"));
+
+                    try {
+                        method.getMethodInfo().rebuildStackMap(cp);
+                    } catch (BadBytecode badBytecode) {
+                        throw new RuntimeException(badBytecode);
+                    }
+                }
+
+                if(cc.getName().equals("com.earth2me.essentials.utils.EnumUtil") && descriptor.contains("Ljava/lang/Enum;")) {
+                    method.getMethodInfo().setDescriptor(descriptor
+                        .replace("Ljava/lang/Enum;", "Ljava/lang/Object;"));
+
+                    try {
+                        method.getMethodInfo().rebuildStackMap(cp);
+                    } catch (BadBytecode badBytecode) {
+                        throw new RuntimeException(badBytecode);
+                    }
+                }
+
+                try {
+                    method.instrument(editor);
+                } catch (CannotCompileException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+
+            return cc.toBytecode();
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static class CompatExprEditor extends ExprEditor {
+        @Override
+        public void edit(MethodCall m) throws CannotCompileException {
+            if(m.getClassName().equals("fr.thekinrar.papyrus.compat.CompatEnumSet") && (m.getMethodName().equals("of") || m.getMethodName().equals("noneOf"))) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatEnumSet." + m.getMethodName() + "($$); }");
+            } else if(m.getClassName().equals("fr.thekinrar.papyrus.compat.CompatEnumMap") && (m.getMethodName().equals("put"))) {
+                m.replace("{ $_ = $0." + m.getMethodName() + "($$); }");
+            }/* else if(m.getClassName().equals("java.lang.Class") && m.getMethodName().equals("getEnumConstants")) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatClass.getEnumConstants($0); }");
+            } else if(m.getClassName().equals("java.lang.Class") && m.getMethodName().equals("isEnum")) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatClass.isEnum($0); }");
+            }*/ else if(m.getEnclosingClass().getName().equals("com.earth2me.essentials.utils.EnumUtil") && m.getClassName().equals("java.lang.reflect.Field") && m.getMethodName().equals("isEnumConstant")) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatField.isEnumConstant($0); }");
+            } else if(m.getClassName().equals("com.earth2me.essentials.utils.EnumUtil") && m.getSignature().contains("Ljava/lang/Enum;")) {
+                m.replace("{ $_ = $0." + m.getMethodName() + "($$); }");
+            } else if(m.getClassName().equals("com.google.common.collect.Maps") && m.getMethodName().equals("newEnumMap")) {
+                m.replace("{ $_ = new fr.thekinrar.papyrus.compat.CompatEnumMap($$); }");
+            } else if(m.getClassName().equals("com.google.common.collect.Sets") && m.getMethodName().equals("immutableEnumSet")) {
+                m.replace("{ $_ = fr.thekinrar.papyrus.compat.CompatEnumSet.of($$); }");
+            }
+        }
+
+        @Override
+        public void edit(Cast c) throws CannotCompileException {
+            try {
+                if(c.getEnclosingClass().getName().equals("com.earth2me.essentials.utils.EnumUtil") && c.getType().getName().equals("java.lang.Enum")) {
+                    c.replace("{ $_ = fr.thekinrar.papyrus.compat.PapyrusCompat.cast($$); }");
+                }
+            } catch (NotFoundException ignored) {}
+        }
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
index 4ae41fd255..212f9db103 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Commodore.java
@@ -14,6 +14,8 @@ import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.JarOutputStream;
 import java.util.zip.ZipEntry;
+
+import fr.thekinrar.papyrus.compat.PapyrusCompat;
 import joptsimple.OptionParser;
 import joptsimple.OptionSet;
 import joptsimple.OptionSpec;
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 004b6ce132..967a182f60 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -297,6 +297,10 @@ public final class CraftMagicNumbers implements UnsafeValues {
     public byte[] processClass(PluginDescriptionFile pdf, String path, byte[] clazz) {
         try {
             clazz = Commodore.convert(clazz, !isLegacy(pdf));
+
+            if(!pdf.isPapyrus()) {
+                clazz = fr.thekinrar.papyrus.compat.PapyrusCompat.transform(clazz);
+            }
         } catch (Exception ex) {
             Bukkit.getLogger().log(Level.SEVERE, "Fatal error trying to convert " + pdf.getFullName() + ":" + path, ex);
         }
-- 
2.27.0

